---
title: "软件测试技术-决策表法"
description: "决策表法"
tags: "软件测试"
date: "2025-05-03"
updateTime: "2025-05-03"
outline: deep
---





          
### 软件测试方法中决策表法的定义和组成部分

#### 1. 决策表法的定义
决策表是一种用于表示复杂逻辑关系的工具，广泛应用于各种工程领域。在软件测试中，决策表是一种非常有效的测试工具，用于管理需求和测试软件。决策表以表格形式展示各种输入条件的组合，这些条件以“真”(T) 和“假”(F) 的形式呈现。输出可能依赖于多个输入条件，决策表还提供了测试所需的一组条件及其相应的操作。

#### 2. 决策表的组成部分
在软件测试中，决策表通常分为以下四个部分：

1. **条件存根（Condition Stubs）**：
   - 位于决策表的左上角，列出了用于确定特定动作或一组动作的条件。

2. **动作存根（Action Stubs）**：
   - 位于决策表的左下角（即条件存根下方），列出了所有可能的动作。

3. **条件条目（Condition Entries）**：
   - 位于决策表的右上角，输入条件值。在条件条目部分，有多个行和列，称为规则（Rule）。

4. **动作条目（Action Entries）**：
   - 位于决策表的右下角，每个条目都有一些相关的动作或动作集，这些值称为输出。





          
### 基于决策表的测试示例

#### 1. 测试用例表
以下是基于决策表的测试用例表，用于确定三个数字中最大的一个：

| 测试用例编号 | 输入 (x, y, z) | 预期结果 | 实际结果 |
|--------------|----------------|----------|----------|
| 1            | (0, 50, 100)   | 无效输入 | 无效输入 |
| 2            | (301, 50, 100) | 无效输入 | 无效输入 |
| 3            | (50, 0, 100)   | 无效输入 | 无效输入 |
| 4            | (50, 301, 100) | 无效输入 | 无效输入 |
| 5            | (50, 100, 0)   | 无效输入 | 无效输入 |
| 6            | (50, 100, 301) | 无效输入 | 无效输入 |
| 7            | (200, 100, 50) | x 最大   | x 最大   |
| 8            | (100, 200, 50) | y 最大   | y 最大   |
| 9            | (50, 100, 200) | z 最大   | z 最大   |
| 10           | (200, 50, 100) | x 最大   | x 最大   |
| 11           | (100, 50, 200) | z 最大   | z 最大   |
| 12           | (50, 200, 100) | y 最大   | y 最大   |
| 13           | (200, 200, 100)| x 最大   | x 最大   |
| 14           | (100, 200, 200)| y 最大   | y 最大   |
| 15           | (200, 100, 200)| x 最大   | x 最大   |

#### 2. JavaScript 代码示例
以下是基于决策表的 JavaScript 代码示例，用于确定三个数字中最大的一个：

```javascript
function findLargestNumber(x, y, z) {
    // 定义有效输入范围
    const min = 1;
    const max = 300;

    // 检查输入是否在有效范围内
    if (x < min || x > max || y < min || y > max || z < min || z > max) {
        return "Invalid input";
    }

    // 确定最大的数字
    if (x > y && x > z) {
        return "x is largest";
    } else if (y > x && y > z) {
        return "y is largest";
    } else if (z > x && z > y) {
        return "z is largest";
    } else {
        return "Impossible";
    }
}

// 测试用例
const testCases = [
    { x: 0, y: 50, z: 100 },
    { x: 301, y: 50, z: 100 },
    { x: 50, y: 0, z: 100 },
    { x: 50, y: 301, z: 100 },
    { x: 50, y: 100, z: 0 },
    { x: 50, y: 100, z: 301 },
    { x: 200, y: 100, z: 50 },
    { x: 100, y: 200, z: 50 },
    { x: 50, y: 100, z: 200 },
    { x: 200, y: 50, z: 100 },
    { x: 100, y: 50, z: 200 },
    { x: 50, y: 200, z: 100 },
    { x: 200, y: 200, z: 100 },
    { x: 100, y: 200, z: 200 },
    { x: 200, y: 100, z: 200 }
];

testCases.forEach(testCase => {
    console.log(`Input: (${testCase.x}, ${testCase.y}, ${testCase.z}) - ${findLargestNumber(testCase.x, testCase.y, testCase.z)}`);
});
```

### 测试结果
```plaintext
Input: (0, 50, 100) - Invalid input
Input: (301, 50, 100) - Invalid input
Input: (50, 0, 100) - Invalid input
Input: (50, 301, 100) - Invalid input
Input: (50, 100, 0) - Invalid input
Input: (50, 100, 301) - Invalid input
Input: (200, 100, 50) - x is largest
Input: (100, 200, 50) - y is largest
Input: (50, 100, 200) - z is largest
Input: (200, 50, 100) - x is largest
Input: (100, 50, 200) - z is largest
Input: (50, 200, 100) - y is largest
Input: (200, 200, 100) - x is largest
Input: (100, 200, 200) - y is largest
Input: (200, 100, 200) - x is largest
```

通过以上测试用例表和 JavaScript 代码，可以清晰地展示基于决策表的测试方法在实际应用中的使用方式。





          
#### **二、判定表驱动法**

1. **核心思想**：  
   - 通过**条件组合**覆盖所有可能的逻辑分支，生成测试用例。  
   - 关键步骤：  
     - 列出所有**输入条件**（如闰年判断规则）。  
     - 组合条件（Y/N），对应**输出结果**。  

2. **判定表结构**（以闰年判断为例）：  

   | **条件/规则**        | R1   | R2   | R3     | R4     |  
   | -------------------- | ---- | ---- | ------ | ------ |  
   | 能被4整除（Y/N）     | Y    | Y    | Y      | N      |  
   | 不能被100整除（Y/N） | Y    | N    | N      | -      |  
   | 能被400整除（Y/N）   | N    | Y    | N      | -      |  
   | **结果**             | 闰年 | 闰年 | 非闰年 | 非闰年 |  

3. **设计流程**：  
   - **Step1**：提取条件（如闰年3个条件）。  
   - **Step2**：组合条件（2^3=8种可能，剔除无效组合）。  
   - **Step3**：映射结果，生成用例（如“能被4整除且不能被100整除→闰年”）。  

4. **适用场景**：  
   - 多条件逻辑判断（如优惠券规则：会员等级+消费金额→折扣）。  

5. **优缺点**：  
   - **优点**：逻辑覆盖全面，避免遗漏。  
   - **缺点**：条件过多时组合爆炸（需优化）。
