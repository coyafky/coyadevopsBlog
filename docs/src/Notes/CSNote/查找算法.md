---
title: "查找算法"
outline: deep
desc: "查找算法"
tags: "Algorithm"
updateTime: "2025-05-15 14:11"
---

# 线性搜索

线性搜索，也称为顺序搜索，是最简单、最直接的搜索算法之一。它的工作原理是按顺序检查数据集合（数组或列表）中的每个元素，直到找到匹配项或遍历整个集合。

![](https://media.geeksforgeeks.org/wp-content/uploads/20240416171353/Linear-Search.webp)

- The Algorithm examines each element, one by one, in the collection, treating each element as a potential match for the key you’re searching for.
    
    该算法逐个检查集合中的每个元素，将每个元素视为要搜索的键的潜在匹配项。
    
- If it finds any element that is exactly the same as the key you’re looking for, the search is successful, and it returns the index of key.
    
    如果它找到与您要查找的键完全相同的任何元素，则搜索成功，并返回键的索引。
    
- If it goes through all the elements and none of them matches the key, then that means “No match is Found”.
    
    如果它遍历了所有元素，但没有一个元素与键匹配，则意味着“未找到匹配项”。
    
    *Consider the array **arr[] = {10, 50, 30, 70, 80, 20, 90, 40}** and **key = 30**考虑数组 arr[] = {10， 50， 30， 70， 80， 20， 90， 40} 和 key = 30*
    
    *.从第一个元素（索引 0）开始，将键与每个元素 （arr[i]） 进行比较。将键与第一个元素 arr[0] 进行比较。由于不相等，迭代器将移动到下一个元素作为潜在匹配项。*
    
    ![](https://media.geeksforgeeks.org/wp-content/uploads/20240416171448/Linear-Search-Algorithm-1.webp)
    
    *将键与下一个元素进行比较 arr[1]。由于不相等，迭代器将移动到下一个元素作为潜在匹配项。*
    
    ![](https://media.geeksforgeeks.org/wp-content/uploads/20240416171553/Linear-Search-Algorithm-2.webp)
    
    *.现在，当将 arr[2] 与 key 进行比较时，该值匹配。因此，线性搜索算法将生成一条成功的消息，并在找到键时返回元素的索引。*
    
    ![](https://media.geeksforgeeks.org/wp-content/uploads/20240416171724/Linear-Search-Algorithm-3.webp)
    

```css
function linearSearch(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            return i;
        }

    }

    return -1

}
const numbers = [2, 4, 67, 8, 44, 6, 12];
console.log(linearSearch(numbers, 8)); // Output: 3 (index of 8 in the array)
console.log(linearSearch(numbers, 28)); // Output: -1 (28 not found in the array)
```

- **Time Complexity: 时间复杂度：**
    - **Best Case**: In the best case, the key might be present at the first index. So the best case complexity is O(1)
        
        最佳情况：在最佳情况下，键可能存在于第一个索引中。因此，最佳情况复杂度为 O（1）
        
    - **Worst Case:** In the worst case, the key might be present at the last index i.e., opposite to the end from which the search has started in the list. So the worst-case complexity is O(N) where N is the size of the list.
        
        最坏情况：在最坏的情况下，键可能出现在最后一个索引处，即与列表中搜索开始的末尾相反。因此，最坏情况的复杂度是 O（N），其中 N 是列表的大小。
        
    - **Average Case:** O(N)
        
        平均情况：O（N）
        
- **Auxiliary Space:** O(1) as except for the variable to iterate through the list, no other variable is used.
    
    辅助空间：O（1） 因为除了要遍历列表的变量外，没有使用其他变量。
    

### Sentinel 线性搜索

Sentinel线性搜索是线性搜索算法的一种优化版本，它在列表的末尾放置一个哨兵值（Sentinel），作为搜索的标记。这种方法的目的是减少每次循环迭代时所需的比较次数，从而提高搜索效率。在Sentinel线性搜索中，将要搜索的元素作为哨兵值放在数组的末尾，当找到目标元素时，可以跳过对数组索引的检查，从而减少每次迭代中的比较次数。

Sentinel线性搜索的优点在于减少了每次循环迭代时的比较次数，从而提高了搜索效率。相比于标准线性搜索，Sentinel线性搜索可以减少一次比较操作。这种方法通过在数组末尾添加哨兵值来实现，使得在找到目标元素时可以更快地结束搜索。

- Initialize the search index variable i to 0.
    
    将搜索索引变量 i 初始化为 0。
    
- Set the last element of the array to the search key.
    
    将数组的最后一个元素设置为搜索键。
    
- While the search key is not equal to the current element of the array (i.e., arr[i]), increment the search index i.
    
    当搜索键不等于数组的当前元素（即 arr[i]）时，递增搜索索引 i。
    
- If i is less than the size of the array or arr[i] is equal to the search key, return the value of i (i.e., the index of the search key in the array).
    
    如果 i 小于数组的大小或 arr[i] 等于搜索键，则返回 i 的值（即数组中搜索键的索引）。
    
- Otherwise, the search key is not present in the array, so return -1 (or any other appropriate value to indicate that the key is not found).
    
    否则，数组中不存在搜索键，因此返回 -1（或任何其他适当的值来指示未找到该键）
    

```css
// Sentinel线性搜索
function sentinelLinearSearch(array, target) {
    const length = array.length;
    const last = array[length - 1];
    array[length - 1] = target; // 将目标值作为哨兵值放在末尾
  
    let i = 0;
    while (array[i] !== target) {
      i++;
    }
  
    array[length - 1] = last; // 恢复末尾元素
  
    if (i < length - 1 || target === array[length - 1]) {
      return i; // 返回索引
    } else {
      return -1; // 未找到返回-1
    }
  }
  
  console.log(sentinelLinearSearch([3, 7, 1, 9, 5], 9)); // 输出: 3
```

尽管在最坏的情况下，时间复杂度两种算法都是 O（n）。与线性搜索相比，哨兵线性搜索中只有比较次数少

## Binary Search

二进制搜索是一种搜索算法，用于查找排序数组中目标值的位置。它的工作原理是反复将搜索间隔一分为二，直到找到目标值或间隔为空。通过将目标元素与搜索空间的中间值进行比较，搜索间隔减半。

### 在数据结构中应用二进制搜索算法的条件：

To apply Binary Search algorithm:要应用二进制搜索算法：

- The data structure must be sorted.
    
    必须对数据结构进行排序。
    
- Access to any element of the data structure takes constant time.
    
    访问数据结构的任何元素都需要恒定的时间。
    

### Binary Search 算法步骤

![](https://media.geeksforgeeks.org/wp-content/uploads/20230522163247/mid-in-binary-search-768.webp)

*Compare the middle element of the search space with the key. 将搜索空间的中间元素与键进行比较。I*

*f the key is found at middle element, the process is terminated.如果在中间元素处找到键，则进程将终止。*

*If the key is not found at middle element, choose which half will be used as the next search space.如果在中间元素处找不到键，请选择将用作下一个搜索空间的一半。
    ◦ If the key is smaller than the middle element, then the left side is used for next search.如果键小于中间元素，则左侧用于下一次搜索。
    ◦ If the key is larger than the middle element, then the right side is used for next search.如果键大于中间元素，则右侧用于下一次搜索。*

*This process is continued until the key is found or the total search space is exhausted.此过程将继续进行，直到找到密钥或耗尽总搜索空间。*

### BinarySearch example

*考虑一个数组 arr[] = {2， 5， 8， 12， 16， 23， 38， 56， 72， 91}，目标 = 23。*

*第一步：计算中点，并将中点元素与键进行比较。如果键小于中间元素，则向左移动，如果键大于中间元素，则将搜索空间向右移动。*

*Key (i.e., 23) is greater than current mid element (i.e., 16). The search space moves to the right.键（即 23）大于当前中间元素（即 16）。搜索空间向右移动。*

![](https://media.geeksforgeeks.org/wp-content/uploads/20230524114905/1.webp)

*Key is less than the current mid 56. The search space moves to the left.键小于当前中间的 56。搜索空间向左移动。*

![](https://media.geeksforgeeks.org/wp-content/uploads/20230524114935/2.webp)

***Second Step:***

*If the key matches the value of the mid element, the element is found and stop search.*

*第二步：如果键与中间元素的值匹配，则找到该元素并停止搜索。*

![](https://media.geeksforgeeks.org/wp-content/uploads/20230726182418/binary-search-step-3.webp)

### Iterative Binary Search Algorithm 迭代二进制搜索算法

```jsx

function iterativeBinarySearch(arr, target) {
    let start =0;
    let end = arr.length -1;
    while(start <= end){
        let mid = Math.floor((start + end)/2);
        if(arr[mid] === target){
            return mid; // 找到目标值，返回索引
        }
        else if(arr[mid] < target){
            start = mid + 1;  // 目标值在右侧，更新起始位置
        }
        else{
            end = mid - 1;  // 目标值在左侧，更新结束位置
        }
    }
    return -1;  // 未找到目标值，返回-1
}

// 示例用法
const sortedArray = [1, 2, 4, 5, 7, 8, 9];
const targetValue = 7;
console.log(iterativeBinarySearch(sortedArray, targetValue)); // 输出: 4 (目标值7的索引)

// 另一个示例
const sortedArray2 = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91];
const targetValue2 = 23;
console.log(iterativeBinarySearch(sortedArray2, targetValue2));
```

时间复杂度：O（log N）

辅助空间：O（1)

### **Recursive Binary Search Algorithm: 递归二叉搜索算法：**

```jsx
// 递归二叉搜索算法
function recursiveBinarySearch(target, arr) {
  // 计算数组的中间索引
  let mid = Math.floor(arr.length / 2);

  // 基本情况：数组为空或未找到目标值
  if (arr.length === 0) {
    return -1;
  }

  // 找到目标值的情况
  if (arr[mid] === target) {
    return mid;
  }

  // 目标值在左侧的情况
  if (target < arr[mid]) {
    return recursiveBinarySearch(target, arr.slice(0, mid));
  }
  // 目标值在右侧的情况
  else {
    let result = recursiveBinarySearch(target, arr.slice(mid + 1));
    return result === -1 ? -1 : mid + 1 + result; // 调整索引位置
  }
}

// 示例用法
const sortedArray = [1, 3, 5, 7, 9, 11, 13];
const targetValue = 7;
console.log(recursiveBinarySearch(targetValue, sortedArray)); // 输出: 3 (目标值7的索引)
```

- **Time Complexity: 时间复杂度：**
    - Best Case: O(1)
        
        最佳案例：O（1）
        
    - Average Case: O(log N)
        
        平均情况：O（log N）
        
    - Worst Case: O(log N)
        
        最坏情况：O（log N）
        
- **Auxiliary Space:** O(1), If the recursive call stack is considered then the auxiliary space will be O(logN).
    
    辅助空间：O（1），如果考虑递归调用堆栈，则辅助空间将为 O（logN）。
    

## Algo BinarySearch

https://algorithm-visualizer.org/branch-and-bound/binary-search

## 对于二叉搜索树的常见问题

### **什么是二进制搜索？**

*二进制搜索是一种在排序数组中查找目标值的有效算法。它的工作原理是反复将搜索间隔分成两半。*

### **二进制搜索有哪些常见缺点**

*二进制搜索的缺点是需要对输入数组进行排序，以决定目标元素可以位于哪一半。因此，对于未排序的数组，我们需要在应用二进制搜索之前对数组进行排序。*

### **什么时候应该使用二进制搜索？**

*在排序数组中搜索目标值时，应使用二进制搜索，尤其是当数组的大小很大时。与线性搜索算法相比，它对于大型数据集特别有效。*

## Meta Binary Search | One-Sided Binary Search元二进制搜索 |单侧二进制搜索

页中也称为单侧二进制搜索）是二进制搜索的一种改进形式，它以增量方式构造数组中目标值的索引。与普通的二进制搜索一样，元二进制搜索需要 O（log n） 时间。

此算法旨在减少在列表中搜索给定元素所需的比较次数。

基本思想是从大小为 n 的初始间隔开始，其中包括整个数组。然后，该算法计算中间元素（如二进制搜索），并将其与目标元素进行比较。如果找到目标元素，搜索将终止。如果中间元素大于目标元素，则算法将新间隔设置为前一个间隔的左半部分，如果中间元素小于目标元素，则将新间隔设置为前一个间隔的右半部分。但是，与二进制搜索不同的是，元二进制搜索不会对循环的每次迭代进行比较。

```jsx
function meta_binary_search(A, target):
    n = length(A)
    interval_size = n
    while interval_size > 0:
        index = min(n - 1, interval_size / 2)
        mid = A[index]
        if mid == target:
            return index
        elif mid < target:
            interval_size = (n - index) / 2
        else:
            interval_size = index / 2
    return -1
```

```jsx
// 单侧二进制搜索算法（查找目标值的左侧边界）
function leftBinarySearch(target, arr) {
  let left = 0;
  let right = arr.length;

  while (left < right) {
    let mid = Math.floor((left + right) / 2);

    if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  return left;
}

// 示例用法
const sortedArray = [1, 2, 2, 2, 3, 4, 5];
const targetValue = 2;
console.log(leftBinarySearch(targetValue, sortedArray)); // 输出: 1（目标值2的左侧边界索引）
```

## **Jump Search 跳转搜索**

。

Jump Search（跳转搜索）是一种用于已排序数组的搜索算法。该算法通过跳跃式地向前搜索，以较小的步长跳过一定数量的元素，从而减少与线性搜索相比的搜索次数。跳转搜索的基本思想是先确定一个跳跃步长（通常是数组长度的平方根），然后在数组中跳跃式地移动，直到找到一个区间，该区间可能包含目标值。然后在这个区间内执行线性搜索以找到确切的目标值位置。

跳转搜索的优点在于它结合了二分搜索和线性搜索的优点，能够在较少的比较次数下快速定位目标值。这种算法适用于较大的已排序数组，并且相对简单易懂。

https://youtu.be/wNOoyZ45SmQ

```jsx
// 跳跃搜索算法
function jumpSearch(arr, target) {
  const length = arr.length;
  const jumpSize = Math.floor(Math.sqrt(length)); // 计算跳跃步长

  // 找到目标值可能存在的块
  let blockStart = 0;
  let blockEnd = jumpSize;
  while (arr[Math.min(blockEnd, length) - 1] < target) {
    blockStart = blockEnd;
    blockEnd += jumpSize;
    if (blockStart >= length) {
      return -1; // 目标值不存在
    }
  }

  // 在块内执行线性搜索
  for (let i = blockStart; i < Math.min(blockEnd, length); i++) {
    if (arr[i] === target) {
      return i; // 找到目标值，返回索引
    }
  }

  return -1; // 未找到目标值
}

// 示例用法
const sortedArray = [1, 3, 5, 7, 9, 11, 13];
const targetValue = 7;
console.log(jumpSearch(sortedArray, targetValue)); // 输出: 3 (目标值7的索引)
```

## **Interpolation Search 插值搜索**

插值搜索（Interpolation Search）是一种用于在已排序数组中查找目标值的搜索算法。与二分搜索不同，插值搜索不是简单地将中间元素作为比较对象，而是根据目标值在数组中的大致位置进行估计，从而更快地定位目标值。这种算法适用于数组中元素分布均匀的情况。

插值搜索的基本思想是根据目标值与数组中最小值和最大值的比较，估计目标值可能在数组中的位置，然后根据这个估计位置进行搜索。通过这种方式，插值搜索可以更快地定位目标值，尤其在元素分布均匀的情况下效果更佳。

https://youtu.be/hF9iJEPegNc

伪代码

```jsx
function interpolationSearch(sortedArray, toFind):
    low = 0
    high = sortedArray.length - 1
    
    while low <= high and toFind >= sortedArray[low] and toFind <= sortedArray[high]:
        position = low + ((toFind - sortedArray[low]) * (high - low)) / (sortedArray[high] - sortedArray[low])
        position = round(position)
        
        if sortedArray[position] == toFind:
            return position
        if sortedArray[position] < toFind:
            low = position + 1
        else:
            high = position - 1
    
    return -1
```

```jsx
function interpolationSearch(sortedArray, toFind) {
    let low = 0;
    let high = sortedArray.length - 1;
    
    while (low <= high && toFind >= sortedArray[low] && toFind <= sortedArray[high]) {
        let position = low + ((toFind - sortedArray[low]) * (high - low)) / (sortedArray[high] - sortedArray[low]);
        position = Math.round(position);
        
        if (sortedArray[position] === toFind) {
            return position;
        }
        if (sortedArray[position] < toFind) {
            low = position + 1;
        } else {
            high = position - 1;
        }
    }
    
    return -1;
}

// 示例用法
const array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const numberToFind = 7;
console.log(interpolationSearch(array, numberToFind)); // 输出: 6
```

## **Exponential Search 指数搜索**

Exponential Search（指数搜索）是一种用于在已排序数组中查找目标值的搜索算法。该算法结合了线性搜索和二分搜索的优点，通过指数级增加搜索范围的方式来快速定位目标值。Exponential Search首先确定一个范围，在这个范围内进行搜索，然后使用二分搜索在这个范围内查找目标值。

以下是Exponential Search的基本步骤：

1. 从第一个元素开始，如果第一个元素就是目标值，则返回其索引。
2. 否则，通过指数级增加索引的方式找到一个范围，在这个范围内目标值可能存在。
3. 在确定的范围内使用二分搜索来查找目标值。

Exponential Search算法的优点在于它可以在较少的比较次数下快速定位目标值，尤其适用于大型已排序数组。

https://youtu.be/BDVYtuWXgXE

```jsx
function exponentialSearch(sortedArray, toFind):
    if sortedArray[0] == toFind:
        return 0
    
    // 找到范围
    index = 1
    while index < sortedArray.length and sortedArray[index] <= toFind:
        index = index * 2
    
    // 在范围内使用二分搜索
    return binarySearch(sortedArray, toFind, index / 2, Math.min(index, sortedArray.length - 1))
```

```jsx
function exponentialSearch(sortedArray, toFind) {
    if (sortedArray[0] === toFind) {
        return 0;
    }

    let index = 1;
    while (index < sortedArray.length && sortedArray[index] <= toFind) {
        index = index * 2;
    }

    return binarySearch(sortedArray, toFind, index / 2, Math.min(index, sortedArray.length - 1));
}

function binarySearch(sortedArray, toFind, start, end) {
    while (start <= end) {
        let mid = Math.floor((start + end) / 2);
        if (sortedArray[mid] === toFind) {
            return mid;
        } else if (sortedArray[mid] < toFind) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }
    return -1;
}

// 示例用法
const array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const numberToFind = 7;
console.log(exponentialSearch(array, numberToFind)); // 输出: 6
```

## **Fibonacci Search 斐波那契搜索**

Fibonacci Search（斐波那契搜索）是一种在已排序数组中查找目标值的搜索算法。与二分搜索类似，Fibonacci Search也将数组分割为不同的部分，但是它使用斐波那契数列来确定分割点，从而在某些情况下比传统的二分搜索更高效。

斐波那契搜索的基本思想是使用斐波那契数列中的数值来确定搜索范围，将数组分割为不同的部分，然后根据目标值与数组中的元素进行比较，逐步缩小搜索范围，直到找到目标值或确定其不存在。

斐波那契搜索算法的优点在于它可以更快地定位目标值，尤其在数组长度不是2的幂次方时效果更佳。

https://youtu.be/5_zlqKi01zQ

```jsx
function fibonacciSearch(sortedArray, toFind):
    // 初始化斐波那契数列
    fibMMm2 = 0
    fibMMm1 = 1
    fibM = fibMMm2 + fibMMm1
    
    // 确定斐波那契数列的范围
    while fibM < sortedArray.length:
        fibMMm2 = fibMMm1
        fibMMm1 = fibM
        fibM = fibMMm2 + fibMMm1
    
    // 初始化偏移量
    offset = -1
    
    // 斐波那契搜索
    while fibM > 1:
        i = Math.min(offset + fibMMm2, sortedArray.length - 1)
        
        if sortedArray[i] < toFind:
            fibM = fibMMm1
            fibMMm1 = fibMMm2
            fibMMm2 = fibM - fibMMm1
            offset = i
        else if sortedArray[i] > toFind:
            fibM = fibMMm2
            fibMMm1 = fibMMm1 - fibMMm2
            fibMMm2 = fibM - fibMMm1
        else:
            return i
    
    if fibMMm1 and sortedArray[offset + 1] == toFind:
        return offset + 1
    return -1
```

```jsx
function fibonacciSearch(sortedArray, toFind) {
    let fibMMm2 = 0;
    let fibMMm1 = 1;
    let fibM = fibMMm2 + fibMMm1;

    while (fibM < sortedArray.length) {
        fibMMm2 = fibMMm1;
        fibMMm1 = fibM;
        fibM = fibMMm2 + fibMMm1;
    }

    let offset = -1;

    while (fibM > 1) {
        let i = Math.min(offset + fibMMm2, sortedArray.length - 1);

        if (sortedArray[i] < toFind) {
            fibM = fibMMm1;
            fibMMm1 = fibMMm2;
            fibMMm2 = fibM - fibMMm1;
            offset = i;
        } else if (sortedArray[i] > toFind) {
            fibM = fibMMm2;
            fibMMm1 = fibMMm1 - fibMMm2;
            fibMMm2 = fibM - fibMMm1;
        } else {
            return i;
        }
    }

    if (fibMMm1 && sortedArray[offset + 1] == toFind) {
        return offset + 1;
    }
    return -1;
}

// 示例用法
const array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const numberToFind = 7;
console.log(fibonacciSearch(array, numberToFind)); // 输出: 6
```

## Comparisons Between Different Searching Algorithms:

- [**Linear Search vs Binary Search**](https://www.geeksforgeeks.org/linear-search-vs-binary-search/)
    
    
    | **Linear Search  线性搜索** | **Binary Search 二进制搜索** |
    | --- | --- |
    | .在线性搜索中，输入数据不需要排序。 | In binary search input data need to be in sorted order.在二进制搜索中，输入数据需要按排序顺序排列。 |
    | It is also called sequential search.它也称为顺序搜索。 | It is also called half-interval search.它也称为半间隔搜索。 |
    | The time complexity of linear search **O(n)**. 线性搜索的时间复杂度 O（n）。 | The time complexity of binary search **O(log n)**二进制搜索的时间复杂度 O（log n）. |
    | Multidimensional array can be used.可以使用多维数组。 | Only single dimensional array is used.仅使用一维数组。 |
    | Linear search performs equality comparisons线性搜索执行相等性比较 | Binary search performs ordering comparisons二进制搜索执行排序比较 |
    | It is less complex. 它不那么复杂。 | It is more complex. 它更复杂。 |
    | It is very slow process.这是一个非常缓慢的过程。 | It is very fast process.这是一个非常快的过程。 |
- [**Is Sentinel Linear Search better than normal Linear Search?**](https://www.geeksforgeeks.org/is-sentinel-linear-search-better-than-normal-linear-search/)

Sentinel线性搜索和普通线性搜索在搜索未排序数组时有所不同。Sentinel线性搜索通过在数组末尾放置一个"哨兵"值（sentinel），从而减少了比较的次数。尽管两种算法的最坏情况时间复杂度都是O(n)，但Sentinel线性搜索在比较次数上有所优化，最多只需要n+2次比较，而普通线性搜索最多需要2n+1次比较。

然而，是否Sentinel线性搜索比普通线性搜索更好还取决于具体情况。有几个因素可能影响结果，包括分支预测、条件检查的成本、编译器优化等。有时循环可能会展开，实际比较次数可能少于n。此外，Sentinel线性搜索需要修改数组（通常不推荐），并且需要保留一个特殊值作为哨兵，这在某些情况下可能不方便。

因此，要确定哪种算法更好，最好进行基准测试。在实际应用中，通常建议使用更简单、易于理解和维护的算法，除非对性能有特定要求。最好不要过度优化，除非确实需要。

## Easy Problems on Searching:

- [**Find the largest three elements in an array**](https://www.geeksforgeeks.org/find-the-largest-three-elements-in-an-array/)

### **查找数组中最大的三个不同元素**

```jsx
function findThreeLargestNumbers(nums) {
    let first , second ,third ;

    if(nums.length < 3){
        return "Array should have at least 3 elements";
    }

    first = second = third = -Infinity;

    for(let i = 0 ; i < nums.length ; i++){
        if(nums[i] > first){
            third = second;
            second = first;
            first = nums[i];
        }
        else if(nums[i] > second){
            third = second;
            second = nums[i];
        }
        else if(nums[i] > third){
            third = nums[i];
        }
    }

    return [third , second , first];
}
let arr = [ 12, 13, 1, 10, 34, 1 ]; 

console.log(findThreeLargestNumbers(arr));
```

- [**Find the Missing Number**](https://www.geeksforgeeks.org/find-the-missing-number/)

### **查找丢失的Number**

1 

```jsx
function findMissingNumber(nums) {
    let i ;
    let temp = [];
    for(i=0;i<nums.length;i++){
        temp[i]=0;
    }

    for(i=0;i<nums.length;i++){
        temp[nums[i]-1]=1;
    }
    let ans =0;
    for(i=0;i<temp.length;i++){
        if(temp[i]==0){
            ans=i+1;
         
        }
    }
    console.log(ans);
}

let arr = [ 1, 3, 7, 5, 6, 2 ];

findMissingNumber(arr);

```

方法 2（使用前 N 个自然数的总和）：该方法背后的想法是使用前 N 个自然数的总和。

```jsx
function findMissingNumber(nums) {
    let total = Math.floor((1 + nums.length) * (nums.length + 2) / 2);
    for(let i =0;i<nums.length;i++){
        total -= nums[i];
        
    }
    return total;
}

 let arr = [ 1, 2, 3, 5 ];
 console.log(findMissingNumber(arr)); // 4
 
```

### 在整数数组中查找第一个重复元素

1. **排序数组**：将整数数组排序，然后遪遍历数组，检查相邻元素是否相等。如果找到相等的元素，则返回该元素作为第一个重复元素。
    
    ```jsx
    function findFirstRepeatNumber(nums) {
        nums.sort((a, b) => a - b);
        for (let i = 0; i < nums.length; i++) {
            if (nums[i] === nums[i + 1]) {
                return nums[i];
            }
        }
        return -1; // 如果没有重复数字，则返回-1
    }
    
    const UnsortedArray = [1, 2, 3, 4, 5, 2, 6, 7];
    
    console.log(findFirstRepeatNumber(UnsortedArray)); // 输出2
    ```
    

1. **使用Set数据结构**：遍历整数数组，将每个元素添加到Set数据结构中。在添加元素时，检查是否已经存在于Set中。如果存在，则返回该元素作为第一个重复元素。
    
    ```jsx
    
    function findFirstRepeatNumber(nums) {
        let set = new Set();
        for (let i = 0; i < nums.length; i++) {
            if(set.has(nums[i])){
                return nums[i];
            }
            else {
                set.add(nums[i]);
            }
        }
        return -1; // 如果没有重复数字，则返回-1
    }
    
    // 测试
    
    const array = [1, 2, 3, 4, 5, 2, 6, 7];
    const result = findFirstRepeatNumber(array);
    console.log(result); // 输出 2
    ```
    

### [**Search, insert and delete in a sorted array**](https://www.geeksforgeeks.org/search-insert-and-delete-in-a-sorted-array/)

对于在JavaScript中对已排序数组进行搜索、插入和删除操作，可以使用以下方法：

1. **搜索(Search)**：对于已排序数组，可以使用二分搜索算法来查找特定元素。这种方法的时间复杂度为O(log n)，其中n是数组的长度。下面是一个示例二分搜索函数：

```jsx
function binarySearch(sortedArray, target) {
    let low = 0;
    let high = sortedArray.length - 1;

    while (low <= high) {
        let mid = Math.floor((low + high) / 2);
        if (sortedArray[mid] === target) {
            return mid; // 找到目标元素，返回索引
        } else if (sortedArray[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    return -1; // 没有找到目标元素
}

```

1. **插入(Insert)**：对于已排序数组，插入元素后仍保持有序性。可以使用二分搜索找到插入位置，然后在该位置插入新元素。以下是一个示例插入函数：

```jsx
function insertIntoSortedArray(sortedArray, element) {
    let index = 0;
    while (index < sortedArray.length && sortedArray[index] < element) {
        index++;
    }
    sortedArray.splice(index, 0, element);
    return sortedArray;
}

```

1. **删除(Delete)**：对于已排序数组，删除特定元素后仍保持有序性。可以先搜索元素的位置，然后删除该位置上的元素。以下是一个示例删除函数：

```jsx
function deleteFromSortedArray(sortedArray, target) {
    let index = binarySearch(sortedArray, target);
    if (index !== -1) {
        sortedArray.splice(index, 1);
    }
    return sortedArray;
}

```

这些函数可以帮助您在JavaScript中对已排序数组执行搜索、插入和删除操作。

### **在排序的二进制数组中计数 1**

### **打印数组中 K 个最大（或最小）元素**

### **在数组中找到先递增然后递减的最大元素**

### **给定大小为 n 且数字为 k 的数组，找到出现次数超过 n/k 次的所有元素**

## Medium Problems on Searching:

### **Find all triplets with zero sum**

1. **排序数组**：首先对给定的整数数组进行排序。排序后的数组可以帮助我们更轻松地处理重复元素和确定三元组中的顺序。
2. **双指针法**：使用双指针技术来查找和为零的三元组。通过固定一个元素，然后使用左右两个指针来找到另外两个元素，使得三者之和为零。这种方法可以在O(n^2)的时间复杂度内解决问题。
3. **避免重复解**：在查找三元组时，需要注意避免重复解。可以在遍历过程中跳过重复元素，以避免重复的三元组。

```jsx
function findTripletsWithZeroSum(arr) {
    let result = [];
    arr.sort((a, b) => a - b); // 对数组进行排序

    for (let i = 0; i < arr.length - 2; i++) {
        if (i === 0 || (i > 0 && arr[i] !== arr[i - 1])) {
            let low = i + 1;
            let high = arr.length - 1;
            let sum = 0 - arr[i];

            while (low < high) {
                if (arr[low] + arr[high] === sum) {
                    result.push([arr[i], arr[low], arr[high]]);
                    while (low < high && arr[low] === arr[low + 1]) low++;
                    while (low < high && arr[high] === arr[high - 1]) high--;
                    low++;
                    high--;
                } else if (arr[low] + arr[high] < sum) {
                    low++;
                } else {
                    high--;
                }
            }
        }
    }

    return result;
}

// 示例用法
const array = [-1, 0, 1, 2, -1, -4];
const triplets = findTripletsWithZeroSum(array);
console.log("所有和为零的三元组为：", triplets);
```