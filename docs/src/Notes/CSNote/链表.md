---
title: "é“¾è¡¨"
outline: deep
desc: "é“¾è¡¨"
tags: "Algorithm"
updateTime: "2025-05-15 14:11"
---


# ğŸ“ ä¸»æ—¨å†…å®¹


# å•é“¾è¡¨çš„æ“ä½œ

## æ€»çš„ä»£ç 

```jsx
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
    this.size = 0;
  }

  // Basic Operations
  insertFirst(data) {
    const newNode = new Node(data);
    newNode.next = this.head;
    this.head = newNode;
    this.size++;
  }

  insertLast(data) {
    this.append(data);
  }

  append(data) {
    const newNode = new Node(data);
    if (!this.head) {
      this.head = newNode;
    } else {
      let current = this.head;
      while (current.next) {
        current = current.next;
      }
      current.next = newNode;
    }
    this.size++;
  }

  insert(index, data) {
    if (index < 0 || index > this.size) {
      throw new Error('Index out of range');
    }
    const newNode = new Node(data);

    if (index === 0) {
      newNode.next = this.head;
      this.head = newNode;
    } else {
      let current = this.head;
      for (let i = 0; i < index - 1; i++) {
        current = current.next;
      }
      newNode.next = current.next;
      current.next = newNode;
    }
    this.size++;
  }

  removeAt(index) {
    if (index < 0 || index >= this.size) {
      throw new Error('Index out of range');
    }
    let current = this.head;
    if (index === 0) {
      this.head = current.next;
    } else {
      for (let i = 0; i < index - 1; i++) {
        current = current.next;
      }
      current.next = current.next.next;
    }
    this.size--;
  }

  removeFirst() {
    if (!this.head) {
      throw new Error('List is empty');
    }
    this.head = this.head.next;
    this.size--;
  }

  removeLast() {
    if (!this.head) {
      throw new Error('List is empty');
    }
    if (!this.head.next) {
      this.head = null;
    } else {
      let current = this.head;
      while (current.next.next) {
        current = current.next;
      }
      current.next = null;
    }
    this.size--;
  }

  // Advanced Operations
  reverse() {
    let prev = null;
    let current = this.head;
    while (current) {
      const next = current.next;
      current.next = prev;
      prev = current;
      current = next;
    }
    this.head = prev;
  }

  contains(data) {
    let current = this.head;
    while (current) {
      if (current.data === data) {
        return true;
      }
      current = current.next;
    }
    return false;
  }

  toArray() {
    const result = [];
    let current = this.head;
    while (current) {
      result.push(current.data);
      current = current.next;
    }
    return result;
  }

  getNthFromEnd(n) {
    if (n < 0 || n >= this.size) {
      throw new Error('Invalid position');
    }
    let slow = this.head;
    let fast = this.head;
    
    for (let i = 0; i < n; i++) {
      fast = fast.next;
    }
    
    while (fast.next) {
      slow = slow.next;
      fast = fast.next;
    }
    
    return slow.data;
  }

  // Utility Methods
  isEmpty() {
    return this.size === 0;
  }

  clear() {
    this.head = null;
    this.size = 0;
  }

  isPalindrome() {
    if (!this.head) return true;
    
    // Convert list to array
    const arr = this.toArray();
    
    // Compare elements from start and end
    let left = 0;
    let right = arr.length - 1;
    while (left < right) {
      if (arr[left] !== arr[right]) {
        return false;
      }
      left++;
      right--;
    }
    return true;
  }

  toString() {
    let current = this.head;
    let result = '';
    while (current) {
      result += current.data + ' -> ';
      current = current.next;
    }
    return result + 'null';
  }
}

// Test Cases
const list = new LinkedList();

// Test Append
list.append(1);
list.append(2);
list.append(3);
console.log('After append:', list.toString()); // 1 -> 2 -> 3 -> null

// Test Insert
list.insert(1, 1.5);
console.log('After insert:', list.toString()); // 1 -> 1.5 -> 2 -> 3 -> null

// Test Remove
list.removeAt(1);
console.log('After remove:', list.toString()); // 1 -> 2 -> 3 -> null

// Test Reverse
list.reverse();
console.log('After reverse:', list.toString()); // 3 -> 2 -> 1 -> null

// Test Contains
console.log('Contains 2:', list.contains(2)); // true
console.log('Contains 5:', list.contains(5)); // false

// Test toArray
console.log('Array representation:', list.toArray()); // [3, 2, 1]

// Test getNthFromEnd
console.log('2nd from end:', list.getNthFromEnd(1)); // 2

// Test Edge Cases
try {
  list.insert(10, 4);
} catch (e) {
  console.log('Insert error:', e.message); // Index out of range
}

try {
  list.removeAt(10);
} catch (e) {
  console.log('Remove error:', e.message); // Index out of range
}

// Test Palindrome
list.clear();
list.append(1);
list.append(2);
list.append(3);
list.append(2);
list.append(1);
console.log('Is palindrome:', list.isPalindrome()); // true

list.clear();
list.append(1);
list.append(2);
list.append(3);
console.log('Is palindrome:', list.isPalindrome()); // false

// Test Clear
list.clear();
console.log('After clear:', list.toString()); // null
console.log('Is empty:', list.isEmpty()); // true

```

**å•é“¾è¡¨**æ˜¯è®¡ç®—æœºç§‘å­¦å’Œç¼–ç¨‹ä¸­çš„åŸºæœ¬æ•°æ®ç»“æ„ï¼Œå®ƒç”±**èŠ‚ç‚¹**ç»„æˆï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹åŒ…å«ä¸€ä¸ª**æ•°æ®**å­—æ®µä»¥åŠå¯¹è¯¥èŠ‚ç‚¹ä¸­ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„**å¼•ç”¨**ã€‚æœ€åä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘**null**Â ï¼Œè¡¨ç¤ºåˆ—è¡¨çš„æœ«å°¾(è¿™ç§çº¿æ€§ç»“æ„æ”¯æŒé«˜æ•ˆçš„æ’å…¥å’Œåˆ é™¤æ“ä½œ)

æ¯ä¸ªèŠ‚ç‚¹ç”±ä¸¤éƒ¨åˆ†ç»„æˆï¼šæ•°æ®å’ŒæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆã€‚æ•°æ®éƒ¨åˆ†å­˜å‚¨å®é™…ä¿¡æ¯ï¼Œè€ŒæŒ‡é’ˆï¼ˆæˆ–å¼•ç”¨ï¼‰éƒ¨åˆ†å­˜å‚¨åºåˆ—ä¸­ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„åœ°å€ã€‚è¿™ç§ç»“æ„å…è®¸èŠ‚ç‚¹åŠ¨æ€é“¾æ¥åœ¨ä¸€èµ·ï¼Œå½¢æˆé“¾çŠ¶åºåˆ—ã€‚


### åˆ›å»ºå•é“¾è¡¨

```jsx
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
    this.size = 0;
  }
}

const list = new LinkedList();
list.head = new Node('A');
list.head.next = new Node('B');
list.head.next.next = new Node('C');
list.head.next.next.next = new Node('D');

console.log(list);   // 
// LinkedList {
//   head: Node { data: 'A', next: Node { data: 'B', next: [Node] } },
//   size: 0
// }

```



åœ¨è¿™ä¸ªä¾‹å­ä¸­æˆ‘ä»¬åˆ›å»ºäº† ä¸€ä¸ªå•é“¾è¡¨ï¼Œä½†æ˜¯æ²¡æœ‰ç»™sizeèµ‹å€¼ï¼Œé‚£æ€ä¹ˆå»æ±‚çš„ï¼ˆsizeçš„ä¸€ä¸ªå•é“¾è¡¨çš„é•¿åº¦å‘¢ï¼Ÿï¼‰

### æ±‚å•é“¾è¡¨çš„é•¿åº¦

**åœ¨æ·»åŠ èŠ‚ç‚¹æ—¶æ›´æ–° size**

è¿™æ˜¯æœ€æœ‰æ•ˆç‡çš„æ–¹æ³•ï¼Œå› ä¸ºå®ƒé¿å…äº†æ¯æ¬¡éœ€è¦é“¾è¡¨é•¿åº¦æ—¶éƒ½éå†æ•´ä¸ªé“¾è¡¨ã€‚

```jsx
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
    this.size = 0;
  }
  add(data) {
    const node = new Node(data); // æ–°å»ºèŠ‚ç‚¹
    if (!this.head) {
      // å¦‚æœæ²¡æœ‰å¤´èŠ‚ç‚¹ å°±æŠŠæ–°å»ºèŠ‚ç‚¹èµ‹å€¼ç»™å¤´èŠ‚ç‚¹
      this.head = node;
    } else {
      // å¦‚æœæœ‰å¤´èŠ‚ç‚¹ å°±æŠŠå½“å‰èŠ‚ç‚¹çš„nextæŒ‡å‘æ–°å»ºèŠ‚ç‚¹
      let current = this.head;
      while (current.next) {
        current = current.next;
      }
      current.next = node; // æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„nextæŒ‡å‘æ–°å»ºèŠ‚ç‚¹
    }
    this.size++; // é“¾è¡¨é•¿åº¦+1
  }
  getSize() {
    return this.size;
  }
}
const list = new LinkedList();
list.add('A');
list.add('B');
list.add('C');
list.add('D');
console.log(list);
console.log(list.getSize());

LinkedList {
  head: Node { data: 'A', next: Node { data: 'B', next: [Node] } },
  size: 4
}
4
```

æ±‚lengthå€¼çš„æ—¶åºå›¾

```mermaid
sequenceDiagram
    participant Main
    participant LinkedList
    participant Node

    Main->>LinkedList: getLength()
    LinkedList->>LinkedList: length = 0
    LinkedList->>LinkedList: current = head
    loop while (current !== null)
        LinkedList->>LinkedList: length++
        LinkedList->>LinkedList: current = current.next
    end
    LinkedList-->>Main: length
```

### ä»£ç 

```jsx
function getLength():
    åˆå§‹åŒ–è®¡æ•°å™¨ length ä¸º 0
    å°† current æŒ‡å‘ head
    éå†é“¾è¡¨ï¼Œç›´åˆ° current ä¸º null:
        å¢åŠ è®¡æ•°å™¨ length
        ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ current = current.next
    è¿”å›è®¡æ•°å™¨ length çš„æœ€ç»ˆå€¼

class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
    this.size = 0;
  }

  getLength() {
    let length = 0;
    let current = this.head;
    while (current !== null) {
      length++;
      current = current.next;
    }
    return length;
  }

}

// ä½¿ç”¨ç¤ºä¾‹
const list = new LinkedList();
list.insertAt(0, 'A');
list.insertAt(1, 'B');
list.insertAt(2, 'C');
list.insertAt(3, 'D');
console.log(list.getLength()); // è¾“å‡º: 4
```

## æ’å…¥

æ’å…¥

ä»å¼€å¤´æ’å…¥


```jsx
function insertAtBeginning(data):
    åˆ›å»ºæ–°èŠ‚ç‚¹ newNodeï¼Œæ•°æ®ä¸º data
    å°† newNode çš„ next æŒ‡é’ˆæŒ‡å‘å½“å‰çš„å¤´èŠ‚ç‚¹ head
    å°† head æŒ‡å‘ newNode
    å¢åŠ é“¾è¡¨çš„é•¿åº¦ size
```


```jsx

class Node {
  constructor(data){
    this.data = data;
    this.next = null;
  }

}
class LinkedList{
  constructor(){
    this.head = null;
    this.size = 0;
  }

  insertAtBeginning(data){
    let newNode = new Node(data);
    newNode.next = this.head;
    this.head = newNode;
    this.size++;
  }
}

const list = new LinkedList();
list.insertAtBeginning('A');
list.insertAtBeginning('B');
list.insertAtBeginning('C');
console.log(list);

LinkedList {
  head: Node { data: 'C', next: Node { data: 'B', next: [Node] } },
  size: 3
}
```

ä»ç»“å°¾æ’å…¥



```jsx
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}
class LinkedList {
  constructor() {
    this.head = null;
    this.size = 0;
  }
  insertAtEnd(data) {
    let newNode = new Node(data);
    if (this.head === null) {
      this.head = newNode;
    }
    let current = this.head;
    while (current.next !== null) {
      current = current.next;
    }
    current.next = newNode;
    this.size++;
  }
}

const list = new LinkedList();
list.insertAtEnd('A');
list.insertAtEnd('B');
list.insertAtEnd('C');
list.insertAtEnd('D');
console.log(list);

LinkedList {
  head: Node {
    data: 'A',
    next: Node {
      data: 'B',
      next: Node {
        data: 'C',
        next: Node {
          data: 'D',
          next: null
        }
      }
    }
  },
  size: 4
}
```

```mermaid
sequenceDiagram
    participant Main
    participant LinkedList
    participant Node

    Main->>LinkedList: insertAtEnd(data)
    LinkedList->>Node: new Node(data)
    Node-->>LinkedList: newNode
    LinkedList->>LinkedList: if (head === null)
    alt head is null
        LinkedList->>LinkedList: head = newNode
    else head is not null
        LinkedList->>LinkedList: current = head
        loop while (current.next !== null)
            LinkedList->>LinkedList: current = current.next
        end
        LinkedList->>LinkedList: current.next = newNode
    end
    LinkedList->>LinkedList: size++
    LinkedList-->>Main: (return)
```

### ç‰¹å®šä½ç½®æ’å…¥


insertAt(1, 'B')

```jsx
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
    this.size = 0;
  }

  insertAt(data, index) {
    // å¦‚æœç´¢å¼•è¶…å‡ºèŒƒå›´ï¼Œç›´æ¥è¿”å›ï¼Œæˆ–è€…æ˜¯æ˜¯é“¾è¡¨ä¸ºç©º
    if (index < 0 || index > this.size) {
      return;
    }
    // åˆ›å»ºèŠ‚ç‚¹
    let newNode = new Node(data);
    // å¦‚æœç´¢å¼•ä¸º0ï¼Œå°†æ–°èŠ‚ç‚¹æ’å…¥åˆ°å¤´éƒ¨
    if (index === 0) {
      newNode.next = this.head;
    } else {
      // å¦åˆ™ï¼Œæ‰¾åˆ°ç´¢å¼•ä½ç½®çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå°†æ–°èŠ‚ç‚¹æ’å…¥åˆ°è¯¥èŠ‚ç‚¹ä¹‹å
      let current = this.head;
      // éå†åˆ°ç´¢å¼•ä½ç½®çš„å‰ä¸€ä¸ªèŠ‚ç‚¹
      for (let i = 0; i < index - 1; i++) {
        current = current.next;
      }
      // å°†æ–°èŠ‚ç‚¹æ’å…¥åˆ°è¯¥èŠ‚ç‚¹ä¹‹å
      newNode.next = current.next;
      // å°†è¯¥èŠ‚ç‚¹çš„ next æŒ‡å‘æ–°èŠ‚ç‚¹
      current.next = newNode;
    }
    // é“¾è¡¨é•¿åº¦åŠ ä¸€
    this.size++;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const list = new LinkedList();
list.insertAt(0, 'A');
list.insertAt(1, 'C');
list.insertAt(1, 'B');
list.insertAt(3, 'D');
console.log(list.toString()); // è¾“å‡º: A B C D

```

```mermaid
sequenceDiagram
    participant User
    participant LinkedList
    participant NodeB
    User->>LinkedList: list.insertAt(1, 'B')
    activate LinkedList
    LinkedList->>NodeB: åˆ›å»ºæ–°èŠ‚ç‚¹ NodeB(data='B')
    activate NodeB
    deactivate NodeB
    LinkedList->>LinkedList: è·å–å¤´èŠ‚ç‚¹ (A)
    LinkedList->>LinkedList: å¾ªç¯éå†åˆ°ç´¢å¼• 0 (A)
    LinkedList->>NodeB: NodeB.next = å½“å‰èŠ‚ç‚¹çš„ next (C)
    LinkedList->>LinkedList: å½“å‰èŠ‚ç‚¹.next = NodeB (B)
    LinkedList->>LinkedList: size++
    deactivate LinkedList
```

## åˆ é™¤

åŒæ ·çš„åˆ é™¤èŠ‚ç‚¹ä¹Ÿæœ‰

### ä»å¼€å¤´åˆ é™¤



```mermaid
sequenceDiagram
    participant Main
    participant LinkedList
    participant Node

    Main->>LinkedList: removeFromBeginning()
    LinkedList->>LinkedList: if (head === null)
    alt list is empty
        LinkedList-->>Main: (return)
    else list is not empty
        LinkedList->>LinkedList: current = head
        LinkedList->>LinkedList: head = current.next
        LinkedList->>LinkedList: size--
    end
    LinkedList-->>Main: (return)
```

```jsx
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
    this.size = 0;
  }

  insertAtEnd(data) {
    let mewNode = new Node(data);
    if (!this.head === null) {
      this.head = newNode;
    } else {
      let current = this.head;
      while (current.next !== null) {
        current = current.next;
      }
      current.next = newNode;
      this.size++;
    }
  }

  removeFromBeginning() {
    if (this.head === null) {
      return;
    }
    let current = this.head;
    this.head = current.next;
    this.size--;
  }
  toString() {
    let current = this.head;
    let result = '';
    while (current !== null) {
      result += current.data + '';
      current = current.next;
    }
    return result.trim();
  }
}

const list = new LinkedList();
list.insertAtEnd('A');
list.insertAtEnd('B');
list.insertAtEnd('C');
list.insertAtEnd('D');
console.log(list.toString());
list.removeFromBeginning();
console.log(list.toString());

```

### ä»ç»“å°¾å¼€å§‹åˆ é™¤



```jsx
class Node {
  constructor(data) {
    this.dada = data;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
    this.isze = 0;
  }

  insertAtEnd(data) {
    let newNode = new Node(data);
    if (!head === null) {
      this.head = newNode;
    } else {
      let current = this.head;
      while (current.next !== null) {
        current = current.next;
      }
      current.next = newNode;
      this.size++;
    }
  }

  removeFormEnd() {
    if (this.head === null) {
      return;
    }
    if (this.head.next === null) {
      this.head = null;
    } else {
      let current = this.head;
      while (current.next.next !== null) {
        current = current.next;
      }
      current.next = null;
    }
    this.size--;
  }
}

const list = LinkedList();
list.insertAtEnd('A');
list.insertAtEnd('B');
list.insertAtEnd('C');
list.insertAtEnd('D');

list.removeFormEnd();
console.log(list);

```

function removeFromEnd():
å¦‚æœé“¾è¡¨ä¸ºç©º (head === null):
ç›´æ¥è¿”å›
å¦‚æœé“¾è¡¨åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ (head.next === null):
å°† head è®¾ç½®ä¸º null
å¦åˆ™:
éå†é“¾è¡¨ç›´åˆ°å€’æ•°ç¬¬äºŒä¸ªèŠ‚ç‚¹ current
å°† current çš„ next æŒ‡é’ˆè®¾ç½®ä¸º null
å‡å°‘é“¾è¡¨çš„é•¿åº¦ size

```mermaid
sequenceDiagram
    participant Main
    participant LinkedList
    participant Node

    Main->>LinkedList: removeFromEnd()
    LinkedList->>LinkedList: if (head === null)
    alt list is empty
        LinkedList-->>Main: (return)
    else list is not empty
        LinkedList->>LinkedList: if (head.next === null)
        alt list has only one node
            LinkedList->>LinkedList: head = null
        else list has more than one node
            LinkedList->>LinkedList: current = head
            loop while (current.next.next !== null)
                LinkedList->>LinkedList: current = current.next
            end
            LinkedList->>LinkedList: current.next = null
        end
        LinkedList->>LinkedList: size--
    end
    LinkedList-->>Main: (return)
```

### åœ¨ç‰¹ç‚¹çš„èŠ‚ç‚¹åˆ é™¤


## æœç´¢

```jsx
function search(target):
    å°† current æŒ‡å‘ head
    éå†é“¾è¡¨ï¼Œç›´åˆ° current ä¸º null:
        å¦‚æœ current çš„æ•°æ®ä¸ç›®æ ‡å€¼åŒ¹é…:
            è¿”å› true
        å¦åˆ™:
            ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ current = current.next
    å¦‚æœéå†å®Œé“¾è¡¨ä»æœªæ‰¾åˆ°åŒ¹é…é¡¹:
        è¿”å› false
```

```mermaid
sequenceDiagram
    participant Main
    participant LinkedList
    participant Node

    Main->>LinkedList: search(target)
    LinkedList->>LinkedList: current = head
    loop while (current !== null)
        LinkedList->>LinkedList: if (current.data === target)
        alt match found
            LinkedList-->>Main: true
        else no match
            LinkedList->>LinkedList: current = current.next
        end
    end
    LinkedList-->>Main: false
```

```jsx
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
    this.size = 0;
  }
  insertAtEnd(data) {
    let newNode = new Node(data);
    if (this.head === null) {
      this.head = newNode;
    } else {
      let current = this.head;
      while (current.next !== null) {
        current = current.next;
      }
      current.next = newNode;
    }
    this.size++;
  }

  search(data) {
    // ä»å¤´èŠ‚ç‚¹å¼€å§‹éå†é“¾è¡¨
    let current = this.head;
    // éå†é“¾è¡¨ï¼Œç›´åˆ°æ‰¾åˆ°ç›®æ ‡æ•°æ®æˆ–è€…éå†å®Œæ•´ä¸ªé“¾è¡¨
    while (current !== null) {
      if (current.data === data) {
        // å¦‚æœæ‰¾åˆ°äº†ç›®æ ‡æ•°æ®ï¼Œè¿”å› true
        return true;
      }
      // å¦åˆ™ï¼Œç»§ç»­éå†ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
      current = current.next;
    }
    // å¦‚æœéå†å®Œæ•´ä¸ªé“¾è¡¨éƒ½æ²¡æœ‰æ‰¾åˆ°ç›®æ ‡æ•°æ®ï¼Œè¿”å› false
    return false;
  }
  Tostring() {
    let current = this.head;
    let result = '';
    while (current !== null) {
      result += current.data + '';
      current = current.next;
    }
    return result.trim();
  }
}
const list = new LinkedList();
list.insertAtEnd('A');
list.insertAtEnd('B');
list.insertAtEnd('C');
list.insertAtEnd('D');
console.log(list.search('A'));
console.log(list.search('E'));
console.log(list.Tostring());

```

### update

```mermaid
sequenceDiagram
    participant Main
    participant LinkedList
    participant Node

    Main->>LinkedList: update(target, newData)
    LinkedList->>LinkedList: current = head
    loop while (current !== null)
        LinkedList->>LinkedList: if (current.data === target)
        alt match found
            LinkedList->>LinkedList: current.data = newData
            LinkedList-->>Main: true
        else no match
            LinkedList->>LinkedList: current = current.next
        end
    end
    LinkedList-->>Main: false
```

## å°†é“¾è¡¨è½¬åŒ–ä¸ºæ•°ç»„

```jsx
function toArray():
    åˆå§‹åŒ–ä¸€ä¸ªç©ºæ•°ç»„ array
    å°† current æŒ‡å‘ head
    éå†é“¾è¡¨ï¼Œç›´åˆ° current ä¸º null:
        å°† current çš„æ•°æ®æ·»åŠ åˆ°æ•°ç»„ä¸­
        ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ current = current.next
    è¿”å›æ•°ç»„ array
```

1. **Main**ï¼šè°ƒç”¨Â `LinkedList`Â çš„Â `toArray`Â æ–¹æ³•ã€‚
2. **LinkedList**ï¼šåˆå§‹åŒ–ä¸€ä¸ªç©ºæ•°ç»„Â `array`ã€‚
3. **LinkedList**ï¼šå°†Â `current`Â æŒ‡å‘é“¾è¡¨çš„å¤´èŠ‚ç‚¹Â `head`ã€‚
4. **LinkedList**ï¼šéå†é“¾è¡¨ï¼Œç›´åˆ°Â `current`Â ä¸ºÂ `null`ã€‚
    - å°†å½“å‰èŠ‚ç‚¹çš„æ•°æ®æ·»åŠ åˆ°æ•°ç»„ä¸­ã€‚
    - ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚
5. **LinkedList**ï¼šè¿”å›æ•°ç»„Â `array`

```mermaid
sequenceDiagram
    participant Main
    participant LinkedList
    participant Node

    Main->>LinkedList: toArray()
    LinkedList->>LinkedList: array = []
    LinkedList->>LinkedList: current = head
    loop while (current !== null)
        LinkedList->>LinkedList: array.push(current.data)
        LinkedList->>LinkedList: current = current.next
    end
    LinkedList-->>Main: array
```

### ä»£ç é€»è¾‘

```jsx
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
    this.size = 0;
  }
 

  // å®šä¹‰ä¸€ä¸ªæ–¹æ³• toArray
  toArray() {
    // åˆå§‹åŒ–ä¸€ä¸ªæŒ‡é’ˆ currentï¼ŒæŒ‡å‘é“¾è¡¨çš„å¤´èŠ‚ç‚¹
    let current = this.head;
    // åˆå§‹åŒ–ä¸€ä¸ªç©ºæ•°ç»„ arrayï¼Œç”¨äºå­˜å‚¨é“¾è¡¨ä¸­çš„æ•°æ®
    let array = [];
    // éå†é“¾è¡¨ï¼Œç›´åˆ° current æŒ‡å‘ nullï¼ˆå³é“¾è¡¨çš„æœ«å°¾ï¼‰
    while (current !== null) {
      // å°†å½“å‰èŠ‚ç‚¹çš„æ•°æ®æ·»åŠ åˆ°æ•°ç»„ä¸­
      array.push(current.data);
      // å°† current æŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
      current = current.next;
    }
    // è¿”å›åŒ…å«é“¾è¡¨ä¸­æ‰€æœ‰æ•°æ®çš„æ•°ç»„
    return array;
  }
}
const list = new LinkedList();
list.insertAtEnd('A');
list.insertAtEnd('B');
list.insertAtEnd('C');
list.insertAtEnd('D');

console.log(list.toArray());

```

## æ£€æŸ¥åˆ—è¡¨æ˜¯å¦ä¸ºç©º

```mermaid
sequenceDiagram
    participant Main
    participant LinkedList

    Main->>LinkedList: isEmpty()
    LinkedList->>LinkedList: if (head === null)
    alt list is empty
        LinkedList-->>Main: true
    else list is not empty
        LinkedList-->>Main: false
    end
```

# question

## åè½¬ä¸€ä¸ªå•é“¾è¡¨



```jsx
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
    this.size = 0;
  }

  reserve() {
    let prev = null;
    let current = this.head;
    let next = null;

    while (current !== null) {
      // ä½¿ç”¨ä¸€ä¸ªå¾ªç¯æ¥éå†é“¾è¡¨ï¼Œåªè¦ current ä¸ä¸º nullï¼Œå°±ç»§ç»­å¾ªç¯
      // next = current.next;ï¼šå°† current çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å­˜å‚¨åœ¨ next å˜é‡ä¸­ã€‚
      next = current.next;
      // å°† current çš„ next æŒ‡é’ˆæŒ‡å‘ prevï¼Œå³å½“å‰èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿™æ ·å°±å®Œæˆäº†å½“å‰èŠ‚ç‚¹çš„åè½¬
      current.next = prev;
      // prev = current;ï¼šå°† prev å˜é‡æ›´æ–°ä¸ºå½“å‰èŠ‚ç‚¹ currentï¼Œè¿™æ ·ä¸‹ä¸€æ¬¡å¾ªç¯æ—¶ï¼Œprev å°±å˜æˆäº†å½“å‰èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ã€‚
      prev = current;
      // current = next;ï¼šå°† current å˜é‡æ›´æ–°ä¸º nextï¼Œè¿™æ ·ä¸‹ä¸€æ¬¡å¾ªç¯æ—¶ï¼Œcurrent å°±å˜æˆäº†ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚
      current = next;
    }
    // this.head = prev;ï¼šå½“å¾ªç¯ç»“æŸæ—¶ï¼Œprev å˜é‡æŒ‡å‘é“¾è¡¨çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯æ–°çš„å¤´èŠ‚ç‚¹ï¼Œå› æ­¤å°† this.head æŒ‡å‘ prevï¼Œå®Œæˆé“¾è¡¨çš„åè½¬
    // æœ€åå°† this.head æŒ‡å‘ prevï¼Œè¿™æ ·é“¾è¡¨çš„å¤´èŠ‚ç‚¹å°±å˜æˆäº†åŸæ¥çš„å°¾èŠ‚ç‚¹ï¼Œå®Œæˆäº†é“¾è¡¨çš„åè½¬ã€‚
    this.head = prev;
  }
}

```

```mermaid
sequenceDiagram
    participant Main
    participant LinkedList
    participant Node

    Main->>LinkedList: reverse()
    LinkedList->>LinkedList: prev = null
    LinkedList->>LinkedList: curr = head
    LinkedList->>LinkedList: next = null
    loop while (curr !== null)
        LinkedList->>LinkedList: next = curr.next
        LinkedList->>LinkedList: curr.next = prev
        LinkedList->>LinkedList: prev = curr
        LinkedList->>LinkedList: curr = next
    end
    LinkedList->>LinkedList: head = prev
    LinkedList-->>Main: (return)
```

### ä½¿ç”¨æ ˆæ¥å®Œæˆé“¾è¡¨çš„åè½¬

```jsx
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
    this.size = 0;
  }

 

  reserveUsingStack() {
    if (this.head === null) {
      return;
    }
    let stack = [];
    let current = this.head;

    while (current !== null) {
      stack.push(current.data);
      current = current.next;
    }

    this.head = stack.pop();
    current = this.head;
    while (stack.length !== 0) {
      current.next = stack.pop();
      current = current.next;
    }
    current.next = null; // æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„ next æŒ‡é’ˆç½®ä¸º null
  }
}

const list = new LinkedList();
list.insertAtEnd('A');
list.insertAtEnd('B');
list.insertAtEnd('C');
list.insertAtEnd('D');
console.log(list.toString()); // è¾“å‡º: ABCD
list.reserveUsingStack();
console.log(list.toString()); // è¾“å‡º: DCBA

```


## **å¿«æ…¢æŒ‡é’ˆæŸ¥æ‰¾å•é“¾è¡¨çš„ä¸­é—´éƒ¨åˆ†**

```jsx
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}
class LinkedList {
  constructor() {
    this.head = null;
    this.size = 0;
  }

  deleteMiddle() {
    // å¦‚æœé“¾è¡¨çš„å¤´èŠ‚ç‚¹ä¸ºç©ºæˆ–åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œåˆ™å°†å¤´èŠ‚ç‚¹è®¾ç½®ä¸ºç©º
    if (this.head === null || this.head.next === null) {
      this.head = null;
      return;
    }
    // ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°é“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹
    let slow = this.head;
    let fast = this.head;
    let prev = null;

    // å¿«æŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨ä¸€æ­¥
    while (fast!== null && fast.next!== null) {
      fast = fast.next.next;
      prev = slow;
      slow = slow.next;
    }
    // å°†å‰ä¸€ä¸ªèŠ‚ç‚¹çš„ next æŒ‡é’ˆæŒ‡å‘ä¸­é—´èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä»è€Œåˆ é™¤ä¸­é—´èŠ‚ç‚¹
    prev.next = slow.next;
    // é“¾è¡¨é•¿åº¦å‡ 1
    this.size--;
  }

}
const list = new LinkedList();
list.insertAtEnd('A');
list.insertAtEnd('B');
list.insertAtEnd('C');
list.insertAtEnd('D');
list.deleteMiddle();
console.log(list.toString());

// é“¾è¡¨åˆå§‹åŒ–ä¸º A -> B -> C -> Dã€‚
// deleteMiddle() è¢«è°ƒç”¨ã€‚
// slow æŒ‡å‘ Aï¼Œfast æŒ‡å‘ Aï¼Œprev ä¸º nullã€‚
// å¾ªç¯è¿­ä»£ï¼š
// fast ç§»åŠ¨åˆ° Cï¼Œslow ç§»åŠ¨åˆ° Bï¼Œprev æ›´æ–°ä¸º Aã€‚
// fast ç§»åŠ¨åˆ° nullï¼Œå¾ªç¯ç»“æŸã€‚
// prev.next (å³ A.next) è¢«è®¾ç½®ä¸º slow.next (å³ C)ã€‚
// é“¾è¡¨å˜ä¸º A -> C -> Dã€‚
// toString() æ–¹æ³•å°†é“¾è¡¨è½¬æ¢ä¸ºå­—ç¬¦ä¸² "ACD"ã€‚

```

```mermaid
sequenceDiagram
    participant Main
    participant LinkedList
    participant Node

    Main->>LinkedList: deleteMiddle()
    LinkedList->>LinkedList: if (head === null || head.next === null)
    alt list is empty or has only one node
        LinkedList->>LinkedList: head = null
        LinkedList-->>Main: (return)
    else list has more than one node
        LinkedList->>LinkedList: slow = head
        LinkedList->>LinkedList: fast = head
        LinkedList->>LinkedList: prev = null
        loop while (fast !== null && fast.next !== null)
            LinkedList->>LinkedList: prev = slow
            LinkedList->>LinkedList: slow = slow.next
            LinkedList->>LinkedList: fast = fast.next.next
        end
        LinkedList->>LinkedList: prev.next = slow.next
        LinkedList->>LinkedList: size--
    end
    LinkedList-->>Main: (return)
```


### ä½¿ç”¨é€’å½’æ¥ è§£å†³

```jsx
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
  }

  insertAtEnd(data) {
    const newNode = new Node(data);
    if (!this.head) {
      this.head = newNode;
    } else {
      let current = this.head;
      while (current.next) {
        current = current.next;
      }
      current.next = newNode;
    }
  }

  findMiddleRecursive(head) {
    return this._findMiddleRecursiveHelper(head, 0)[0];
  }

  _findMiddleRecursiveHelper(node, count) {
    if (node === null) {
      return [null, count]; // Base case: end of list
    }

    const [middleNode, updatedCount] = this._findMiddleRecursiveHelper(node.next, count + 1);

    if (updatedCount % 2 === 1 && updatedCount > 1) { // Odd number of nodes, return the middle
      return [node, updatedCount];
    } else if (updatedCount % 2 === 0 && updatedCount > 0) { //Even number of nodes, return the second middle
      return [middleNode, updatedCount];
    } else {
      return [middleNode, updatedCount];
    }
  }

  toString() {
    let current = this.head;
    let result = '';
    while (current !== null) {
      result += current.data + ' ';
      current = current.next;
    }
    return result.trim();
  }
}

const list = new LinkedList();
list.insertAtEnd('A');
list.insertAtEnd('B');
list.insertAtEnd('C');
list.insertAtEnd('D');
list.insertAtEnd('E');
list.insertAtEnd('F');

const middleNode = list.findMiddleRecursive(list.head);
console.log("Original List:", list.toString());
console.log("Middle Node:", middleNode ? middleNode.data : "List is empty");

const list2 = new LinkedList();
list2.insertAtEnd('A');
list2.insertAtEnd('B');
list2.insertAtEnd('C');
list2.insertAtEnd('D');
list2.insertAtEnd('E');

const middleNode2 = list2.findMiddleRecursive(list2.head);
console.log("\nOriginal List:", list2.toString());
console.log("Middle Node:", middleNode2 ? middleNode2.data : "List is empty");

```

## å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹

(æ€è·¯ä¹Ÿæ˜¯åŒæŒ‡é’ˆ)

```mermaid
sequenceDiagram
    participant Main
    participant LinkedList
    participant Node

    Main->>LinkedList: getNthFromEnd(N)
    LinkedList->>LinkedList: if (head === null || N <= 0)
    alt list is empty or N is invalid
        LinkedList-->>Main: -1
    else list is not empty and N is valid
        LinkedList->>LinkedList: first = head
        LinkedList->>LinkedList: second = head
        loop move first N steps
            alt first is null
                LinkedList-->>Main: -1
            else first is not null
                LinkedList->>LinkedList: first = first.next
            end
        end
        loop while (first !== null)
            LinkedList->>LinkedList: first = first.next
            LinkedList->>LinkedList: second = second.next
        end
        LinkedList-->>Main: second.data
    end
```

1. **Main**Â è°ƒç”¨Â `list.getNthFromEnd(N)`ï¼š
    - `LinkedList`Â æ£€æŸ¥é“¾è¡¨æ˜¯å¦ä¸ºç©ºæˆ–Â `N`Â æ˜¯å¦æ— æ•ˆï¼ˆå°äºç­‰äº 0ï¼‰ã€‚
        - å¦‚æœé“¾è¡¨ä¸ºç©ºæˆ–Â `N`Â æ— æ•ˆï¼Œè¿”å›Â `1`ã€‚
    - åˆå§‹åŒ–ä¸¤ä¸ªæŒ‡é’ˆÂ `first`Â å’ŒÂ `second`Â ä¸ºÂ `head`ã€‚
    - å°†Â `first`Â æŒ‡é’ˆå‘å‰ç§»åŠ¨Â `N`Â æ­¥ã€‚
        - å¦‚æœåœ¨ç§»åŠ¨è¿‡ç¨‹ä¸­Â `first`Â å˜ä¸ºÂ `null`ï¼Œåˆ™è¿”å›Â `1`ã€‚
    - åŒæ—¶ç§»åŠ¨Â `first`Â å’ŒÂ `second`Â æŒ‡é’ˆï¼Œç›´åˆ°Â `first`Â åˆ°è¾¾é“¾è¡¨æœ«å°¾ã€‚
    - è¿”å›Â `second`Â æŒ‡é’ˆæŒ‡å‘çš„èŠ‚ç‚¹çš„æ•°æ®ã€‚

```jsx
function getNthFromEnd(N):
    å¦‚æœé“¾è¡¨ä¸ºç©ºæˆ– N æ— æ•ˆ (head === null || N <= 0):
        è¿”å› -1
    åˆå§‹åŒ– first ä¸º head
    åˆå§‹åŒ– second ä¸º head
    å°† first æŒ‡é’ˆå‘å‰ç§»åŠ¨ N æ­¥:
        å¦‚æœ first å˜ä¸º null:
            è¿”å› -1
        å¦åˆ™:
            å°† first ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    åŒæ—¶ç§»åŠ¨ first å’Œ second æŒ‡é’ˆï¼Œç›´åˆ° first åˆ°è¾¾é“¾è¡¨æœ«å°¾:
        å°† first ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        å°† second ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    è¿”å› second æŒ‡é’ˆæŒ‡å‘çš„èŠ‚ç‚¹çš„æ•°æ®
```

```jsx
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
    this.size = 0;
  }

  getNthFromEnd(n) {
    let current = this.head;
    if (this.head === null || n < 0) {
      return -1;
    }
    let first = this.head;
    let second = this.head;

    for (let i = 0; i < n; i++) {
      if (first === null) {
        return -1;
      }
      first = first.next;
    }
    while (first !== null) {
      first = first.next;
      second = second.next;
    }
    return second.data;
  }

}

let list = new LinkedList();
list.add(1);
list.add(2);
list.add(3);
list.add(4);
list.add(5);
console.log(list.getNthFromEnd(2));

```

## å›æ–‡é“¾è¡¨

### åŒæŒ‡é’ˆæ³•

1. **æ‰¾åˆ°é“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹**ï¼šä½¿ç”¨å¿«æ…¢æŒ‡é’ˆæ³•æ‰¾åˆ°é“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹ã€‚
2. **åè½¬ååŠéƒ¨åˆ†é“¾è¡¨**ï¼šå°†é“¾è¡¨çš„ååŠéƒ¨åˆ†åè½¬ã€‚
3. **æ¯”è¾ƒå‰åŠéƒ¨åˆ†å’Œåè½¬åçš„ååŠéƒ¨åˆ†**ï¼šé€ä¸ªæ¯”è¾ƒå‰åŠéƒ¨åˆ†å’Œåè½¬åçš„ååŠéƒ¨åˆ†çš„èŠ‚ç‚¹å€¼ã€‚
4. **æ¢å¤é“¾è¡¨**ï¼šå¦‚æœéœ€è¦ï¼Œå¯ä»¥å°†é“¾è¡¨æ¢å¤åˆ°åŸå§‹çŠ¶æ€ã€‚

```mermaid
sequenceDiagram
    participant Main
    participant LinkedList
    participant Node

    Main->>LinkedList: isPalindrome()
    LinkedList->>LinkedList: slow = head
    LinkedList->>LinkedList: fast = head
    loop while (fast !== null && fast.next !== null)
        LinkedList->>LinkedList: slow = slow.next
        LinkedList->>LinkedList: fast = fast.next.next
    end
    LinkedList->>LinkedList: secondHalf = reverse(slow)
    LinkedList->>LinkedList: firstHalf = head
    loop while (secondHalf !== null)
        LinkedList->>LinkedList: if (firstHalf.data !== secondHalf.data)
        alt not equal
            LinkedList-->>Main: false
        else equal
            LinkedList->>LinkedList: firstHalf = firstHalf.next
            LinkedList->>LinkedList: secondHalf = secondHalf.next
        end
    end
    LinkedList-->>Main: true
```

# åŒé“¾è¡¨



## ä»€ä¹ˆæ˜¯ åŒå‘é“¾è¡¨

**åŒå‘é“¾è¡¨**æ˜¯ä¸€ç§ç”±ä¸€ç»„èŠ‚ç‚¹ç»„æˆçš„æ•°æ®ç»“æ„ï¼Œæ¯ä¸ªèŠ‚ç‚¹åŒ…å«ä¸€ä¸ª**å€¼**å’Œ**ä¸¤ä¸ªæŒ‡é’ˆ**ï¼Œä¸€ä¸ªæŒ‡å‘åˆ—è¡¨ä¸­çš„**å‰ä¸€ä¸ªèŠ‚ç‚¹**ï¼Œä¸€ä¸ªæŒ‡å‘åˆ—è¡¨ä¸­çš„**ä¸‹ä¸€ä¸ªèŠ‚ç‚¹**ã€‚è¿™å…è®¸åœ¨**ä¸¤ä¸ªæ–¹å‘**ä¸Šé«˜æ•ˆåœ°éå†åˆ—è¡¨ï¼Œä½¿å…¶é€‚åˆéœ€è¦é¢‘ç¹**æ’å…¥**å’Œ**åˆ é™¤**çš„åº”ç”¨ç¨‹xu

### åŒå‘é“¾è¡¨å’Œå•é“¾è¡¨çš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ

**åŒå‘é“¾è¡¨å’Œå•é“¾è¡¨çš„åŒºåˆ«ï¼š**

| **ç‰¹æ€§** | **åŒå‘é“¾è¡¨** | **å•é“¾è¡¨** |
| --- | --- | --- |
| æŒ‡é’ˆæ•°é‡ | æ¯ä¸ªèŠ‚ç‚¹æœ‰ä¸¤ä¸ªæŒ‡é’ˆ (å‰é©±å’Œåç»§) | æ¯ä¸ªèŠ‚ç‚¹åªæœ‰ä¸€ä¸ªæŒ‡é’ˆ (åç»§) |
| éå†æ–¹å‘ | å¯å‘å‰å’Œå‘åéå† | åªèƒ½å‘å‰éå† |
| æ’å…¥/åˆ é™¤æ•ˆç‡ | æ’å…¥å’Œåˆ é™¤æ“ä½œåœ¨å·²çŸ¥èŠ‚ç‚¹çš„æƒ…å†µä¸‹æ•ˆç‡æ›´é«˜ | æ’å…¥å’Œåˆ é™¤æ“ä½œéœ€è¦éå†åˆ°ç›®æ ‡èŠ‚ç‚¹ï¼Œæ•ˆç‡è¾ƒä½ |
| å†…å­˜å¼€é”€ | æ¯ä¸ªèŠ‚ç‚¹éœ€è¦æ›´å¤šå†…å­˜ç©ºé—´ | æ¯ä¸ªèŠ‚ç‚¹éœ€è¦è¾ƒå°‘å†…å­˜ç©ºé—´ |



### åœ¨JavaScriptä¸­ åŒå‘é“¾è¡¨çš„ è¡¨ç¤º

### æ•°æ®ç»“æ„ä¸­çš„ è¡¨ç¤º


```jsx
1. Data
    
    æ•°æ®
    
2. A pointer to the next node (**next**)
    
    æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆÂ **next**Â ï¼‰çš„æŒ‡é’ˆ
    
3. A pointer to the previous node (**prev**)
    
    æŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ (Â **prev**Â )
```

### head and tail

- **`head`Â (å¤´æŒ‡é’ˆ):**Â æŒ‡å‘é“¾è¡¨ä¸­ç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆã€‚ å¦‚æœé“¾è¡¨ä¸ºç©ºï¼Œåˆ™Â `head`Â ä¸ºÂ `null`Â æˆ–Â `nullptr`Â (å–å†³äºç¼–ç¨‹è¯­è¨€)ã€‚ é€šè¿‡Â `head`Â æŒ‡é’ˆï¼Œå¯ä»¥ä»é“¾è¡¨çš„å¤´éƒ¨å¼€å§‹éå†æ•´ä¸ªé“¾è¡¨ã€‚
- **`tail`Â (å°¾æŒ‡é’ˆ):**Â æŒ‡å‘é“¾è¡¨ä¸­æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆã€‚ å¦‚æœé“¾è¡¨ä¸ºç©ºï¼Œåˆ™Â `tail`Â ä¸ºÂ `null`Â æˆ–Â `nullptr`ã€‚ é€šè¿‡Â `tail`Â æŒ‡é’ˆï¼Œå¯ä»¥ä»é“¾è¡¨çš„å°¾éƒ¨å¼€å§‹åå‘éå†æ•´ä¸ªé“¾è¡¨ï¼Œæˆ–è€…åœ¨é“¾è¡¨å°¾éƒ¨é«˜æ•ˆåœ°æ·»åŠ æ–°èŠ‚ç‚¹ã€‚

**ä¸ºä»€ä¹ˆè¦ä½¿ç”¨Â `head`Â å’ŒÂ `tail`Â æŒ‡é’ˆï¼Ÿ**

ä½¿ç”¨Â `head`Â å’ŒÂ `tail`Â æŒ‡é’ˆçš„ä¸»è¦åŸå› æ˜¯æé«˜æ•ˆç‡ï¼š

- **å¿«é€Ÿè®¿é—®é“¾è¡¨çš„èµ·å§‹å’Œç»“æŸä½ç½®:**Â æ— éœ€éå†æ•´ä¸ªé“¾è¡¨å°±èƒ½ç›´æ¥è®¿é—®ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªèŠ‚ç‚¹ã€‚ è¿™åœ¨è®¸å¤šæ“ä½œä¸­ï¼Œä¾‹å¦‚åœ¨é“¾è¡¨å¤´éƒ¨æˆ–å°¾éƒ¨æ·»åŠ æˆ–åˆ é™¤èŠ‚ç‚¹æ—¶ï¼Œéå¸¸é‡è¦ã€‚
- **ç®€åŒ–æ“ä½œ:**Â `head`Â å’ŒÂ `tail`Â æŒ‡é’ˆç®€åŒ–äº†é“¾è¡¨æ“ä½œçš„å®ç°ï¼Œç‰¹åˆ«æ˜¯å¯¹äºåœ¨é“¾è¡¨ä¸¤ç«¯è¿›è¡Œæ’å…¥å’Œåˆ é™¤æ“ä½œã€‚ ä¾‹å¦‚ï¼Œåœ¨é“¾è¡¨å°¾éƒ¨æ·»åŠ èŠ‚ç‚¹æ—¶ï¼Œåªéœ€è¦ä¿®æ”¹Â `tail`Â æŒ‡é’ˆå’Œæ–°èŠ‚ç‚¹çš„æŒ‡é’ˆå³å¯ï¼Œè€Œæ— éœ€éå†æ•´ä¸ªé“¾è¡¨ã€‚

å‡è®¾ä¸€ä¸ªåŒå‘é“¾è¡¨åŒ…å«èŠ‚ç‚¹ 10, 20, 30ã€‚ é‚£ä¹ˆï¼š

- `head`Â æŒ‡å‘åŒ…å«æ•°æ® 10 çš„èŠ‚ç‚¹ã€‚
- `tail`Â æŒ‡å‘åŒ…å«æ•°æ® 30 çš„èŠ‚ç‚¹ã€‚

### åœ¨JavaScriptä¸­çš„ è¡¨ç¤º

```jsx
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
    this.prev = null;
  }
}

class DoublyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.size = 0;
  }

  // Add node at start
  insertFirst(data) {
    const newNode = new Node(data);
    if (!this.head) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      newNode.next = this.head;
      this.head.prev = newNode;
      this.head = newNode;
    }
    this.size++;
  }

  // Add node at end
  insertLast(data) {
    const newNode = new Node(data);
    if (!this.tail) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      newNode.prev = this.tail;
      this.tail.next = newNode;
      this.tail = newNode;
    }
    this.size++;
  }

  // Insert at index
  insert(index, data) {
    if (index < 0 || index > this.size) {
      throw new Error('Index out of range');
    }

    if (index === 0) return this.insertFirst(data);
    if (index === this.size) return this.insertLast(data);

    const newNode = new Node(data);
    let current = this.head;
    for (let i = 0; i < index - 1; i++) {
      current = current.next;
    }

    newNode.next = current.next;
    newNode.prev = current;
    current.next.prev = newNode;
    current.next = newNode;
    this.size++;
  }

  // Remove first node
  /**
   * ç§»é™¤é“¾è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
   * @throws {Error} å¦‚æœé“¾è¡¨ä¸ºç©ºï¼Œåˆ™æŠ›å‡ºé”™è¯¯
   */
  removeFirst() {
    // å¦‚æœé“¾è¡¨ä¸ºç©ºï¼Œåˆ™æŠ›å‡ºé”™è¯¯
    if (!this.head) {
      throw new Error('List is empty');
    }

    // å¦‚æœé“¾è¡¨ä¸­åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹
    if (this.head === this.tail) {
      // å°†å¤´èŠ‚ç‚¹å’Œå°¾èŠ‚ç‚¹éƒ½è®¾ç½®ä¸ºnull
      this.head = null;
      this.tail = null;
    } else {
      // å°†å¤´èŠ‚ç‚¹æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
      this.head = this.head.next;
      // å°†æ–°çš„å¤´èŠ‚ç‚¹çš„prevæŒ‡é’ˆè®¾ç½®ä¸ºnull
      this.head.prev = null;
    }
    // é“¾è¡¨é•¿åº¦å‡1
    this.size--;
  }

  // Remove last node
  removeLast() {
    if (!this.tail) {
      throw new Error('List is empty');
    }

    if (this.head === this.tail) {
      this.head = null;
      this.tail = null;
    } else {
      this.tail = this.tail.prev;
      this.tail.next = null;
    }
    this.size--;
  }

  // Remove at index
  /**
   * ç§»é™¤é“¾è¡¨ä¸­çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹
   * @throws {Error} å¦‚æœé“¾è¡¨ä¸ºç©ºï¼Œåˆ™æŠ›å‡ºé”™è¯¯
   */
  removeLast() {
    // å¦‚æœé“¾è¡¨ä¸ºç©ºï¼Œåˆ™æŠ›å‡ºé”™è¯¯
    if (!this.tail) {
      throw new Error('List is empty');
    }

    // å¦‚æœé“¾è¡¨ä¸­åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹
    if (this.head === this.tail) {
      // å°†å¤´èŠ‚ç‚¹å’Œå°¾èŠ‚ç‚¹éƒ½è®¾ç½®ä¸ºnull
      this.head = null;
      this.tail = null;
    } else {
      // å°†å°¾èŠ‚ç‚¹æŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹
      this.tail = this.tail.prev;
      // å°†æ–°çš„å°¾èŠ‚ç‚¹çš„nextæŒ‡é’ˆè®¾ç½®ä¸ºnull
      this.tail.next = null;
    }
    // é“¾è¡¨é•¿åº¦å‡1
    this.size--;
  }
  /**
   * åè½¬é“¾è¡¨
   */
  reverse() {
    // å½“å‰èŠ‚ç‚¹æŒ‡å‘å¤´èŠ‚ç‚¹
    let current = this.head;
    // å¤´èŠ‚ç‚¹æŒ‡å‘å°¾èŠ‚ç‚¹
    this.head = this.tail;
    // å°¾èŠ‚ç‚¹æŒ‡å‘å½“å‰èŠ‚ç‚¹
    this.tail = current;

    // éå†é“¾è¡¨
    while (current) {
      // ä¿å­˜å½“å‰èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
      const next = current.next;
      // å½“å‰èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹
      current.next = current.prev;
      // å½“å‰èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘ä¿å­˜çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
      current.prev = next;
      // å½“å‰èŠ‚ç‚¹æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
      current = next;
    }
  }

  /**
   * æ£€æŸ¥é“¾è¡¨ä¸­æ˜¯å¦åŒ…å«æŒ‡å®šçš„æ•°æ®
   * @param {*} data - éœ€è¦æ£€æŸ¥çš„æ•°æ®
   * @returns {boolean} - å¦‚æœé“¾è¡¨ä¸­åŒ…å«æŒ‡å®šæ•°æ®ï¼Œè¿”å›trueï¼›å¦åˆ™è¿”å›false
   */
  contains(data) {
    // ä»é“¾è¡¨çš„å¤´èŠ‚ç‚¹å¼€å§‹éå†
    let current = this.head;
    // éå†é“¾è¡¨
    while (current) {
      // å¦‚æœå½“å‰èŠ‚ç‚¹çš„æ•°æ®ç­‰äºæŒ‡å®šçš„æ•°æ®
      if (current.data === data) {
        // è¿”å›true
        return true;
      }
      // å½“å‰èŠ‚ç‚¹æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
      current = current.next;
    }
    // å¦‚æœéå†å®Œé“¾è¡¨éƒ½æ²¡æœ‰æ‰¾åˆ°æŒ‡å®šçš„æ•°æ®ï¼Œè¿”å›false
    return false;
  }

  // Convert to array
  /**
   * å°†é“¾è¡¨è½¬æ¢ä¸ºæ•°ç»„
   * @returns {Array} - åŒ…å«é“¾è¡¨ä¸­æ‰€æœ‰èŠ‚ç‚¹æ•°æ®çš„æ•°ç»„
   */
  toArray() {
    // åˆ›å»ºä¸€ä¸ªç©ºæ•°ç»„ç”¨äºå­˜å‚¨ç»“æœ
    const result = [];
    // å½“å‰èŠ‚ç‚¹æŒ‡å‘å¤´èŠ‚ç‚¹
    let current = this.head;
    // éå†é“¾è¡¨
    while (current) {
      // å°†å½“å‰èŠ‚ç‚¹çš„æ•°æ®æ·»åŠ åˆ°ç»“æœæ•°ç»„ä¸­
      result.push(current.data);
      // å½“å‰èŠ‚ç‚¹æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
      current = current.next;
    }
    // è¿”å›ç»“æœæ•°ç»„
    return result;
  }

  // Get nth from end
  /**
   * è·å–é“¾è¡¨ä¸­å€’æ•°ç¬¬nä¸ªèŠ‚ç‚¹çš„æ•°æ®
   * @param {number} n - éœ€è¦è·å–çš„èŠ‚ç‚¹ä½ç½®ï¼Œä»0å¼€å§‹è®¡æ•°
   * @returns {*} - å€’æ•°ç¬¬nä¸ªèŠ‚ç‚¹çš„æ•°æ®
   * @throws {Error} å¦‚æœnå°äº0æˆ–å¤§äºç­‰äºé“¾è¡¨é•¿åº¦ï¼Œåˆ™æŠ›å‡ºé”™è¯¯
   */
  getNthFromEnd(n) {
    // æ£€æŸ¥næ˜¯å¦æœ‰æ•ˆ
    if (n < 0 || n >= this.size) {
      // å¦‚æœnæ— æ•ˆï¼ŒæŠ›å‡ºé”™è¯¯
      throw new Error('Invalid position');
    }

    // ä»é“¾è¡¨çš„å°¾èŠ‚ç‚¹å¼€å§‹éå†
    let current = this.tail;
    // éå†é“¾è¡¨
    for (let i = 0; i < n; i++) {
      // å½“å‰èŠ‚ç‚¹æŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹
      current = current.prev;
    }
    // è¿”å›å½“å‰èŠ‚ç‚¹çš„æ•°æ®
    return current.data;
  }

  // Check if empty
  isEmpty() {
    return this.size === 0;
  }

  // Clear the list
  clear() {
    this.head = null;
    this.tail = null;
    this.size = 0;
  }

  // Check if palindrome
  /**
   * æ£€æŸ¥é“¾è¡¨æ˜¯å¦ä¸ºå›æ–‡é“¾è¡¨
   * @returns {boolean} - å¦‚æœé“¾è¡¨æ˜¯å›æ–‡é“¾è¡¨ï¼Œè¿”å›trueï¼›å¦åˆ™è¿”å›false
   */
  isPalindrome() {
    // å¦‚æœé“¾è¡¨ä¸ºç©ºï¼Œç›´æ¥è¿”å›true
    if (!this.head) return true;

    // åˆå§‹åŒ–ä¸¤ä¸ªæŒ‡é’ˆï¼Œåˆ†åˆ«æŒ‡å‘é“¾è¡¨çš„å¤´èŠ‚ç‚¹å’Œå°¾èŠ‚ç‚¹
    let left = this.head;
    let right = this.tail;

    // éå†é“¾è¡¨ï¼Œç›´åˆ°ä¸¤ä¸ªæŒ‡é’ˆç›¸é‡æˆ–è€…äº¤å‰
    while (left !== right && left.prev !== right) {
      // å¦‚æœä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘çš„èŠ‚ç‚¹æ•°æ®ä¸ç›¸ç­‰ï¼Œè¯´æ˜é“¾è¡¨ä¸æ˜¯å›æ–‡é“¾è¡¨ï¼Œè¿”å›false
      if (left.data !== right.data) return false;
      // å·¦æŒ‡é’ˆå‘å³ç§»åŠ¨
      left = left.next;
      // å³æŒ‡é’ˆå‘å·¦ç§»åŠ¨
      right = right.prev;
    }
    // å¦‚æœéå†å®Œé“¾è¡¨éƒ½æ²¡æœ‰æ‰¾åˆ°ä¸ç›¸ç­‰çš„èŠ‚ç‚¹ï¼Œè¯´æ˜é“¾è¡¨æ˜¯å›æ–‡é“¾è¡¨ï¼Œè¿”å›true
    return true;
  }

  // String representation
  toString() {
    let current = this.head;
    let result = '';
    while (current) {
      result += current.data + ' <-> ';
      current = current.next;
    }
    return result + 'null';
  }
}

// Test Cases
const dll = new DoublyLinkedList();

// Test Insert First/Last
dll.insertFirst(3);
dll.insertFirst(2);
dll.insertFirst(1);
dll.insertLast(4);
console.log('After insertFirst/Last:', dll.toString()); // 1 <-> 2 <-> 3 <-> 4 <-> null

// Test Remove First/Last
dll.removeFirst();
console.log('After removeFirst:', dll.toString()); // 2 <-> 3 <-> 4 <-> null

dll.removeLast();
console.log('After removeLast:', dll.toString()); // 2 <-> 3 <-> null

// Test Insert/Remove at index
dll.insert(1, 2.5);
console.log('After insert at index 1:', dll.toString()); // 2 <-> 2.5 <-> 3 <-> null

dll.removeAt(1);
console.log('After remove at index 1:', dll.toString()); // 2 <-> 3 <-> null

// Test Reverse
dll.reverse();
console.log('After reverse:', dll.toString()); // 3 <-> 2 <-> null

// Test Contains
console.log('Contains 2:', dll.contains(2)); // true
console.log('Contains 5:', dll.contains(5)); // false

// Test toArray
console.log('Array representation:', dll.toArray()); // [3, 2]

// Test getNthFromEnd
console.log('1st from end:', dll.getNthFromEnd(0)); // 2

// Test Edge Cases
try {
  dll.insert(10, 4);
} catch (e) {
  console.log('Insert error:', e.message); // Index out of range
}

try {
  dll.removeAt(10);
} catch (e) {
  console.log('Remove error:', e.message); // Index out of range
}

// Test Palindrome
dll.clear();
dll.insertLast(1);
dll.insertLast(2);
dll.insertLast(3);
dll.insertLast(2);
dll.insertLast(1);
console.log('Is palindrome:', dll.isPalindrome()); // true

dll.clear();
dll.insertLast(1);
dll.insertLast(2);
dll.insertLast(3);
console.log('Is palindrome:', dll.isPalindrome()); // false

// Test Clear
dll.clear();
console.log('After clear:', dll.toString()); // null
console.log('Is empty:', dll.isEmpty()); // true

```

# å¾ªç¯é“¾è¡¨

### å¾ªç¯é“¾è¡¨çš„ä»‹ç»

å¾ªç¯é“¾è¡¨æ˜¯ä¸€ç§é“¾è¡¨çš„å˜ä½“ï¼Œå…¶ä¸­æœ€åä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå½¢æˆä¸€ä¸ªé—­ç¯ã€‚ä¸å•é“¾è¡¨å’ŒåŒé“¾è¡¨ä¸åŒï¼Œå¾ªç¯é“¾è¡¨æ²¡æœ‰æ˜ç¡®çš„â€œç»“æŸâ€èŠ‚ç‚¹ï¼Œå› ä¸ºå®ƒçš„æœ€åä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚è¿™ç§ç»“æ„åœ¨æŸäº›åº”ç”¨ä¸­éå¸¸æœ‰ç”¨ï¼Œä¾‹å¦‚å®ç°å¾ªç¯é˜Ÿåˆ—æˆ–è½®è¯¢ç³»ç»Ÿã€‚

### å¾ªç¯é“¾è¡¨çš„ç‰¹ç‚¹ï¼š

1. **é—­ç¯ç»“æ„**ï¼šæœ€åä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚
2. **çµæ´»æ€§**ï¼šå¯ä»¥è½»æ¾åœ°åœ¨é“¾è¡¨ä¸­å¾ªç¯éå†ã€‚
3. **èŠ‚çœç©ºé—´**ï¼šä¸éœ€è¦é¢å¤–çš„æŒ‡é’ˆæ¥è¡¨ç¤ºé“¾è¡¨çš„ç»“æŸã€‚

All

### å¾ªç¯é“¾è¡¨çš„CRUDåŠŸèƒ½

### 1. åˆ›å»ºï¼ˆCreateï¼‰

åˆ›å»ºä¸€ä¸ªå¾ªç¯é“¾è¡¨éœ€è¦å®šä¹‰ä¸€ä¸ªèŠ‚ç‚¹ç»“æ„ï¼Œå¹¶åˆå§‹åŒ–é“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚

```jsx
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

class CircularLinkedList {
    constructor() {
        this.head = null;
    }

    append(data) {
        const newNode = new Node(data);
        if (!this.head) {
            this.head = newNode;
            newNode.next = this.head;
        } else {
            let temp = this.head;
            while (temp.next !== this.head) {
                temp = temp.next;
            }
            temp.next = newNode;
            newNode.next = this.head;
        }
    }
}

```

### 2. è¯»å–ï¼ˆReadï¼‰

è¯»å–å¾ªç¯é“¾è¡¨ä¸­çš„æ•°æ®å¯ä»¥é€šè¿‡éå†é“¾è¡¨æ¥å®ç°ã€‚

```jsx
    display() {
        if (!this.head) {
            console.log("List is empty");
            return;
        }
        let temp = this.head;
        do {
            console.log(temp.data);
            temp = temp.next;
        } while (temp !== this.head);
    }

```

### 3. æ›´æ–°ï¼ˆUpdateï¼‰

æ›´æ–°å¾ªç¯é“¾è¡¨ä¸­çš„èŠ‚ç‚¹æ•°æ®å¯ä»¥é€šè¿‡éå†é“¾è¡¨æ‰¾åˆ°ç›®æ ‡èŠ‚ç‚¹å¹¶æ›´æ–°å…¶æ•°æ®ã€‚

```jsx
    update(oldData, newData) {
        if (!this.head) {
            console.log("List is empty");
            return;
        }
        let temp = this.head;
        do {
            if (temp.data === oldData) {
                temp.data = newData;
                return;
            }
            temp = temp.next;
        } while (temp !== this.head);
        console.log("Data not found");
    }

```

### 4. åˆ é™¤ï¼ˆDeleteï¼‰

åˆ é™¤å¾ªç¯é“¾è¡¨ä¸­çš„èŠ‚ç‚¹éœ€è¦æ‰¾åˆ°ç›®æ ‡èŠ‚ç‚¹å¹¶è°ƒæ•´å…¶å‰ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆã€‚

```jsx
    delete(data) {
        if (!this.head) {
            console.log("List is empty");
            return;
        }
        if (this.head.data === data) {
            if (this.head.next === this.head) {
                this.head = null;
            } else {
                let temp = this.head;
                while (temp.next !== this.head) {
                    temp = temp.next;
                }
                temp.next = this.head.next;
                this.head = this.head.next;
            }
            return;
        }
        let current = this.head;
        let previous = null;
        do {
            previous = current;
            current = current.next;
            if (current.data === data) {
                previous.next = current.next;
                return;
            }
        } while (current !== this.head);
        console.log("Data not found");
    }
}

```

### ç¤ºä¾‹ä½¿ç”¨

```jsx
const cll = new CircularLinkedList();
cll.append(1);
cll.append(2);
cll.append(3);
cll.display(); // è¾“å‡º: 1 2 3

cll.update(2, 4);
cll.display(); // è¾“å‡º: 1 4 3

cll.delete(1);
cll.display(); // è¾“å‡º: 4 3

```